---json
{
  "title": "The Transition to a Cloud-Native Developer",
  "description": "A look at what being a cloud-native developer means and some of the skills you will need to improve/gain to be successful.",
  "date": "2023-03-16",
  "hero_image": "./cloud-native-hero.jpg",
  "tags": [
    "Cloud Native",
    "Career Development",
    "System Design"
  ]
}
---

To me, one of the allures of software development is what [Fred Brooks](https://en.wikiquote.org/wiki/Fred_Brooks) famously labeled as working "only slightly removed from pure thought-stuff. [Software developers] build [their] castles in the air, from air, creating by exertion of the imagination." This starting from nothing and building up something of value is enjoyable. Put simply, software engineers want to write software. This thought will often come up when discussing supporting activities a developer needs to do to facilitate their work such as documentation, meetings, etc. This also can be applied to the behavior of software developers where they will often rather write their own code to solve a problem before they reach for an outside solution.

Historically this avoidance of using “someone else’s code” was mostly seen in not using external libraries. More recently we have probably seen a bit of the opposite of this (looking at you [left-pad](https://www.theregister.com/2016/03/23/npm_left_pad_chaos/)). In cloud software development I think the bigger risk is writing your own code when cloud-native services/features can take care of that functionality. This has been something I have thought a lot about over the last little while and came to a head recently after reading a [great article](https://architectelevator.com/cloud/cloud-decoupling-cost/) by Gregor Hohpe and some recent work experiences.

Writing our own code is comfortable. For many of us, this is something we have been doing for many years. We feel like we understand where its sharp edges are and have honed this craft. Conversely, cloud services and features feel like they are changing daily and it takes effort to keep up with all of these changes. In Gregor’s article above he shares an example of a piece of software where it would update a DynamoDB table and then push a message onto EventBridge in a Lambda function. This code isn’t short on the usage of cloud services. Gregor suggests that it can be developed in a more cloud-native fashion though. The change he suggests is, instead of manually pushing events to EventBridge, to use the built-in features of [DyanmoDB streams](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Streams.html) and [EventBridge Pipes](https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-pipes.html) to replace that code with a simple configuration. He looks at this from the point of view of its effects on costs but it also shows a more cloud-native way of thinking. This is a change from solving a problem with code and replacing it with solving the issue with the platform.

A recent work experience follows this same pattern. High-level we were trying to, in a sub-second manner, apply a subset of modifying database queries against a separate database system. There were various complexities and issues with this and where we had gotten to was honestly pretty impressive. There was a lot of extremely clever software engineering applied to this problem. All this being said it was the wrong solution. The end solution ignores all of that impressive engineering and replaces it with an out-of-the-box cloud-native solution. We were able to replace the code with configuration. With a solution like this, there is some concern of having to learn new tools and maybe your use cases don't fit exactly into its functionality. While these are legitimate concerns we shouldn't let that stop us from trying these things out as the benefits can far outweigh the costs.

A large part of cloud-native architecture is utilizing the platform you are built upon. To do this you need to understand what that platform provides, its different use cases, and where you can apply them. With the speed of development and releases in the cloud this can be a daunting task. That said, you do not need to know everything about every service/feature of your chosen platform. However, having a cursory knowledge of what is possible is extremely useful. On top of this, having an understanding of the patterns that a cloud platform enables for you is critical. A migration from [pets to cattle](https://www.copado.com/devops-hub/blog/pets-vs-cattle-more-than-an-analogy-for-modern-infrastructures) and embracing the ephemeral nature of compute resources. Building decoupled components that can be independently scaled and monitored. There are many components to cloud-native software but they all track back to improving the experience for developers and users by utilizing what is unique about the cloud.

By embracing what the cloud can give you your application can benefit from all that is provided by your platform. This can increase the speed of feature delivery and resiliency. While it takes effort to embrace this model, it is the way the industry is moving and has been moving for some time. What cloud-native development looks like for your application may look slightly different than someone else's development but if you are being able to put off [undifferentiated heavy lifting](https://nodramadevops.com/2019/02/identifying-undifferentiated-heavy-lifting/), speed up development, improve resiliency, and leverage all of this for an improved experience for your users you are on the right track.
