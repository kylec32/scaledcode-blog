---json
{
  "title": "Building a FIPS-140 Compliant HTTPD Server",
  "description": "A dive into how to setup a FIPS-140 compliant Apache HTTPD server in Linux. A missing guide if you will that I wish I would have found when I had to take this journey",
  "date": "2023-10-23",
  "draft": true,

  "tags": [
    "Compliance",
    "Regulation",
    "security",
    "How-To"
  ]
}
---

Occasionally you will find yourself given the opportunity it work within a new set of constraints in the technology field. I find it is almost always beneficial to embrace these situations as there is always something interesting to learn from them even if you don't need to develop within those constraints for long, the learnings from that environment can help you in other, seemingly unrelated, areas. One of these constraints I have had to work within is that of needing to meet compliance with FIPS-140 requirements. 

### What is FIPS 140

The National Institute of Standards and Technology (NIST) issues the 140 series of FIPS (Federal Information Processing Standards) as a collection of standards related to computer security standards. There are two accepted level of these standards acceptted at the time of writinging, 140-2 (valid until September 21, 2026) and 140-3 (which started accepting application September 22, 2020). These standards serve as descirption of what standards hardware and software cryptographic modules must meet in order to be used by the federal governments of the United State of America and Canada. The requirements set out in FIPS 140 cover not only the cyrptographic modules themselves but also the documentation surrounding them. In the industry you will hear two different terms being thrown around related to FIPS, _FIPS Approved_ and _FIPS Validated_. _FIPS Approved_ unfortunately is meaningless in the eyes of the government and simply means that a system self reports as compliant with the standards set out in FIPS 140. _FIPS Approved_ on the other hand has meaning to the government. Being _FIPS Approved_ means that a cryptographic module has gone through testing by the _Cryptographic Module Validation Program_ (CMVP) that oversees the testing that verifies a cryptographic module actually follows the standards set out in the FIPS standards. You can view every module that has passed this validation [online](https://csrc.nist.gov/projects/cryptographic-module-validation-program/validated-modules/search). As part of this validation requirements may be set out by the cryptographic module that specify what is and isn't allowed when using that module to stay within the requirements of FIPS validation. Thus, it is only when you meet the two conditions, _1_ use an _approved_ cryptographic module, and _2_, use approved algorithms and configuration, that FIPS compliance is obtained in the eyes of the government. 

### Should everyone strive to meet FIPS-140 standards? 

Short answer, no. System providers should only strive to meet the FIPS-140 standards if required by their customers (almost exclusively federal government entities.) Why is this the case? It mainly comes down to the speed of progress within the FIPS-140 standards and the ease of use of systems in FIPS-140 modes. Being a government program it doesn't always move fast and thus could (and does) fall behind industry best practices. For example, while FIPS-140 does allow the usage of PBKDF, it wouldn't allow you to use something like Argon2id. I like to describe FIPS 140 as raising the floor of security higher so that you can't sink below a certain level. However FIPS-140 compliance always leads to lowering the ceiling as well. New best practices and improved algorithms may be implicitly disallowed by the standards because it doesnt' allow for those unknowns to enter the discussion. The final bit that can hurt you with striving for FIPS 140 compliance is that it will often lead to you needing to use outdated dependencies with known vulnerabilities because you are not allowed to use the updated modules as they haven't been re-validated by the regulated bodies. This leads to at least a six month delay into receiving updates even in the best cases is what appears to be the case. 

So to reiterate. Do not strive for FIPS-140 approval unless explicitly required and it will be abundatly clear when your customer has these requirements as they will tell you that directly. 

### Getting a FIPS Validated HTTP Service

With the background out of the way of what FIPS-140 is and why you shouldn't shoot for it without being required we are now ready to dive into the core of what this post is about. I did find myself in the need to implementing FIPS 140 compliance in a system. This had far reaching effects but we will focus on just one of the, the revese proxy bundled with the application. All cryptography done by the system needed to be performed in a FIPS validated way, this includes TLS. This particular application is fronted by an HTTPD service that serves as a reverse proxy. It does TLS termination and re-establishes a TLS connection to the backend services. Httpd has been around since [1995](https://httpd.apache.org/) and been the self-proclaimed "most popular web server since 1996". If any system is likely used by the government and already had to go through this process it is likely Apache HTTPD. The first (re)discovery was that HTTPD doesn't implment its own cryptography but delegates that to OpenSSL. Thus it wasn't HTTPD that would need to be FIPS validated but instead OpenSSL, "Simple enough," we thought. OpenSSL is also no spring chicken having released initially in 1998. It serves as a foundation of much of the TLS performed in the world. While not always for [good reasons](https://en.wikipedia.org/wiki/Heartbleed), OpenSSL is well known in the industry.  Looking up "OpenSSL and FIPS" sure enough we are presented with "OpenSSL version 3 contains a FIPS module." Well this sounds like it will be easy. Checking the `mod_ssl` documentation we can see that there is a flag for turning on [FIPS mode](https://httpd.apache.org/docs/current/mod/mod_ssl.html#sslfips). Unfortunately this is where the complexities come. For simply grabbing the latest httpd with bundled OpenSSL and trying to flip on the flag it wouldn't actually work. This comes down to the fact that only specific versions of OpenSSL are FIPS validated and the FIPS module isn't part of the OpenSSL download in any distribution that I have seen. This started us down the path of doing a custom build of OpenSSL. 

### Building OpenSSL Including the FIPS Module

First we need to determine what is the latest version of OpenSSL that has been FIPS validated. This can currently be found [here](https://www.openssl.org/source/). At the time of writing that is 3.0.8. This is a good example of the concern above where, when you need to meet FIPS validated module requirements, you end up using older software with known issues. OpenSSL even has a page detailing on the known exploits [in the FIPS version](https://www.openssl.org/news/fips-cve.html). At this point we can retrieve the source code and then we must follow the documentation specifically for building a FIPS validated version from the [security policy](https://www.openssl.org/source/fips-doc/openssl-3.0.8-security-policy-2023-05-05.pdf) and the [code documentation](https://github.com/openssl/openssl/blob/master/README-FIPS.md). This is an example of the required documentation for FIPS described above. For us that led to downloading the 3.0.8 code. Verifying its signature. Running the configure script with `enable-avcp-test` and `enable-fips`. The AVCP (Automated Cryptographic Validation Protoco) tests allow verification of correct usage of the algorithms and `enable-fips` of course indicates that we will be installing the FIPS provider. Then we do the actual build process which could look something like `make -j && make install_sw && make install_fips && make install_ssldirs`. At this point we have an OpenSSL build with FIPS _capabilities_, we just need to configure them to be turned on. 

### Configure OpenSSL Providers

The way that OpenSSL 3 works is it delegates the implementation of the actual cryptography to configured providers of cryptography. It is via this system that we can facilitate the use of our newly compiled FIPS validated code. Out of the box OpenSSL uses the "default" provider which collects all of OpenSSL's built-in algorithms. For many providers (legacy, base, and null) the configuration is extremely simple and you can simply say you want to use the provider and it will be used. For the FIPS provider it is a little more involved. The first step is to generate the fips configuration file. This can be performed by running the falling `openssl fipsinstall -module <path_to>/fips.so -out <path_to>/fips.cnf -provider_name fips`. This will run a self-test of OpenSSL and write out some configuration to the passed in file path that will be used by OpenSSL when running with the FIPS provider. The documentation makes it clear that this conf file must not be copied from one machien to another, it must be generated on each machine. At this point we can go into our openssl.cnf file and find the section that says `# .include fipsmodule.cnf` and replace it with `.include <path_to>/fips.cnf`. We then will find the section that says `default = default_sect` and replace it with `fips = fips_sect` followed by a new line and `base = base_sect`. Finally we replace the `[default_sect]` with `[fips_sect]` followed by `activate=1` and `[base_sect]` with `activate=1`. With all these changes we should be good to go. We removed the default provider so that those non-FIPS validated implementations won't be used. We enabled the FIPS module (passing in its custom config for that particular machine) and also enabled the base provder which implements all non-crytographic algorithms that may be asked of OpenSSL. Since these aren't cryptographic they don't need to be FIPS validated. You can confirm the providers were set up as intended by calling `openssl list -providers`

So now we have a FIPS validated OpenSSL but we need to get it working with HTTPD. We chose to recompile HTTPD pointing at the new OpenSSL. 

### Compiling and Configuring HTTPD

There are a lot of different flags that can be passed to the build of httpd but the most important one for our usecase here is the `--with-ssl=` flag which should be pointed at the custom build of OpenSSL. Outside of that one small change this is just a regular build of httpd so follow the documentation for guidance on how to perform this task. Now we can specify the `SSLFIPS on` flag in our httpd conf file and it should work. Check the logs of httpd and it should list that it is running OpenSSL in FIPS validated mode. 

### Summing it Up

Once you have the above process down it isn't necessarily complex but it is surely more complicated than just downloading a prebundled version that is ready to go in mere moments. That said, if it is required this is the path we must follow. Hopefully having the above documented can make the path you may need to follow much simpler. 